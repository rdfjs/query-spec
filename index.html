<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>RDF/JS: Query specification</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
  <script class="remove">
    var respecConfig = {
      specStatus: "CG-DRAFT",
      shortName: "rdfjs",
      subtitle: "RDF/JS: Query specification",
      processVersion: 2020,
      edDraftURI: "https://github.com/rdfjs/query-spec/",
      issueBase: "https://github.com/rdfjs/query-spec/issues/",
      githubAPI: "https://api.github.com/repos/rdfjs/query-spec",
      // TODO: testSuiteURIkey: "",
      editors: [
          {
            name: "Ruben Taelman",
            url: "https://www.rubensworks.net/#me",
            company: "Ghent University – imec",
            companyURL: "http://idlab.ugent.be/",
            w3cid: 84199
          },
          {
            name: "Jacopo Scazzosi",
            url: "https://jacoscaz.com/#me",
            company: "Beautiful Interactions s.r.l.",
            companyURL: "https://beautifulinteractions.com/",
            w3cid: 72858
          }
      ],
      authors:  [
          {
            name: "Ruben Taelman",
            url: "https://www.rubensworks.net/#me",
            company: "Ghent University – imec",
            companyURL: "http://idlab.ugent.be/",
            w3cid: 84199
          },
          {
            name: "Jacopo Scazzosi",
            url: "https://jacoscaz.com/#me",
            company: "Beautiful Interactions s.r.l.",
            companyURL: "https://beautifulinteractions.com/",
            w3cid: 72858
          }
      ],
      bugTracker:             {
        open: "https://github.com/rdfjs/query-spec/issues?utf8=%E2%9C%93&q=is%3Aissue%20is%3Aopen%20",
        new:  "https://github.com/rdfjs/query-spec/issues/new"
      },
      otherLinks: [{
        key: "Version control",
        data: [{
          value: "Github Repository",
          href: "https://github.com/rdfjs/query-spec"
        }]
      }],
      wg: "RDF JavaScript Libraries Community Group",
      wgURI: "https://www.w3.org/community/rdfjs/",
      wgPublicList: "public-rdfjs",
      maxTocLevel: 2
    };
  </script>
</head>
<body>
<section id="abstract">
  <h2>Abstract</h2>
  <p>
    The scope of this specification is to provide a way to query over quads, as defined in the <a href="http://rdf.js.org/data-model-spec/#quad-interface">RDF/JS: Data model specification</a>.
    Similar to the <a href="http://rdf.js.org/data-model-spec/">RDF/JS: Data model specification</a>, this is a low-level specification that provides only essential methods for working across query engine component.
    High-level querying interfaces can and should be using libraries that implement this interface.
  </p>
  <p>The specification itself consists of a core-part that is the base for all other functions defined.</p>
  <p>Low-level methods are using explicit parameters that cannot be omitted.</p>
  <p>Additional high-level interfaces are outside of the scope of this specification and should be defined elsewhere.</p>
</section>

<section id="sotd">
  <p>
    This document provides a specification of an interface for RDF query engines in a JavaScript environment.
	The task force which defines this interface was formed by RDF JavaScript library developers with the wish to make existing
    and future libraries interoperable. This definition strives to provide the minimal necessary
    interface to enable interoperability of RDF querying libraries.
  </p>
  <p>
    <strong>Currently, this specification only provides interfaces that enable filtering quads based on expressions.</strong>
    Additional interfaces for more general querying support will be defined in the future.
  </p>
</section>

<section>
  <h2>Design elements and principles</h2>
  <ul>
    <li><em>All <a href="http://rdf.js.org/data-model-spec/#design-elements-and-principles">design elements and principles from the RDF/JS data model specification</a> apply here as well.</em></li>
    <li>Interfaces do not conflict with other RDF/JS interfaces, and users and implementers of purely other RDF/JS interfaces should not be aware of the interfaces in this specification if they are not needed.</li>
    <li>Data interfaces should not contain methods, as to enable straightforward transmission over low-level communication protocols such as Web Assembly.</li>
    <li>To enable querying over large graphs, interfaces should handle quads in a streaming manner, such as the <a href="https://rdf.js.org/stream-spec/">RDF/JS stream interfaces</a>.</li>
  </ul>
</section>

<section>
  <h2>Bindings interfaces</h2>
  
  This section introduces interfaces related to query result bindings.
  In SPARQL SELECT queries, these bindings correspond to <a href="https://www.w3.org/TR/sparql11-query/#sparqlSolutions">solution mappings</a>.

  <section>
    <h2>Goals</h2>
    <ul>
      <li>Query engines should be able to interact with bindings created by different libraries.</li>
      <li>Bindings are immutable</li>
      <li>Interfaces do no specify how bindings are stored in memory</li>
    </ul>
  </section>
  
  <section data-dfn-for="Bindings">
    <h3><dfn>Bindings</dfn> interface</h3>

    <pre class="idl">
    interface Bindings {
      iterable&lt;(Variable, Term)&gt;;

      readonly attribute string type;
      readonly attribute unsigned long size;

      boolean has((Variable or string) key);
      Term? get((Variable or string) key);
      Bindings set((Variable or string) key, Term value);
      Bindings delete((Variable or string) key);
      iterable&lt;Variable&gt; keys();
      iterable&lt;Term&gt; values();
      boolean equals(optional Bindings? other);
      void forEach(BindingsEntryCallback callback);
      Bindings filter(BindingsFilterCallback callback);
      Bindings map(BindingsMapCallback callback);
      Bindings merge(Bindings other);
      Bindings mergeWith(BindingsMergeCallback callback, Bindings other);
    };
    
    callback BindingsEntryCallback = undefined (Term value, Variable key);
    callback BindingsFilterCallback = boolean (Term value, Variable key);
    callback BindingsMapCallback = Term (Term value, Variable key);
    callback BindingsMergeCallback = Term (Term self, Term other, Variable key);
    </pre>

    <p>
      A <code>Bindings</code> is an object that represents the mapping of variables to RDF values using an immutable Map-like representation.
      This means that methods such as <code>set</code> and <code>delete</code> do not modify this instance,
      but they return a new Bindings instance that contains the modification.
    </p>
    <p>
      Every <code>Bindings</code> object is an iterable over its entries, where each entry is a tuple of <code>Variable</code> key and <code>Term</code> value.
    </p>
    
    <h3>Attributes</h3>
    
    <p>
      <dfn>type</dfn> contains the constant <code>"bindings"</code>.
    </p>
    <p>
      <dfn>size</dfn> is a field that contains the number of entries in this <code>Bindings</code> object.
    </p>
    
    <h3>Methods</h3>
    
    <p>
      <dfn>has</dfn> checks if a binding exist for the given variable.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
    </p>
    <p>
      <dfn>get</dfn> returns the <code>Term</code> value bound to the given variable, or <code>undefined</code> if no binding exists.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
    </p>
    <p>
      <dfn>set</dfn> returns a new <code>Bindings</code> object by adding the given variable and value mapping.
      If the variable already exists in the binding, then the existing mapping is overwritten.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
      <dfn>value</dfn> is the <code>Term</code> value that must be bound.
    </p>
    <p>
      <dfn>delete</dfn> returns a new <code>Bindings</code> object by removing the given variable.
      If the variable does not exist in the binding, a copy of the <code>Bindings</code> object is returned.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
    </p>
    <p>
      <dfn>keys</dfn> returns an iterable of <code>Variable</code> instances for which mappings exist.
    </p>
    <p>
      <dfn>values</dfn> returns an iterable of <code>Term</code> values for which mappings exist.
    </p>
    <p>
      <dfn>equals</dfn> returns <code>true</code>
      when called with parameter <code>other</code>
      on an object <code>Bindings</code> if
      all of the conditions below hold:
    </p>
    <ul>
      <li><code>other</code> is <em>neither</em> <code>null</code> nor <code>undefined</code>;</li>
      <li>The keys in the this and the other <code>Bindings</code> object are equal (following the semantics of <code>Variable.equals</code>);</li>
      <li>For each key, the values within each <code>Bindings</code> object are equal (following the semantics of <code>Term.equals</code>);</li>
    </ul>
    <p>
      <dfn>forEach</dfn> invokes the <code>callback</code> for all entries in this <code>Bindings</code> object,
      with the entry value <code>Term</code> as first argument, and the entry key <code>Variable</code> as second argument.
    </p>
    <p>
      <dfn>filter</dfn> returns a new <code>Bindings</code> object by filtering entries using <code>callback</code>,
      with the entry value <code>Term</code> as first argument, and the entry key <code>Variable</code> as second argument.
      Returning <code>true</code> indicates that this entry must be contained in the resulting <code>Bindings</code> object.
    </p>
    <p>
      <dfn>map</dfn> returns a new <code>Bindings</code> object by mapping entries using <code>callback</code>,
      with the entry value <code>Term</code> as first argument, and the entry key <code>Variable</code> as second argument.
      The original <code>Term</code> value is replaced by the returned <code>Term</code> value in the resulting <code>Bindings</code> object.
    </p>
    <p>
      <dfn>merge</dfn> merges this <code>Bindings</code> object with another <code>Bindings</code> object.
      If a merge conflict occurs (this and other have an equal variable with unequal value), then <code>undefined</code> is returned.
    </p>
    <p>
      <dfn>mergeWith</dfn> merges this <code>Bindings</code> object with another <code>Bindings</code> object,
      where merge conflicts can be resolved using <code>callback</code>.
      <code>callback</code> is invoked with the value <code>Term</code> of the first <code>Bindings</code> object as first argument,
      the value <code>Term</code> of the second <code>Bindings</code> object as second argument,
      and the key <code>Variable</code> as third argument,
      where the returned <code>Term</code> is considered the merged value.
    </p>
  </section>

  <section data-dfn-for="BindingsFactory">
    <h3><dfn>BindingsFactory</dfn> interface</h3>

    <pre class="idl">
    interface BindingsFactory {
      Bindings bindings(Array&lt;(Variable, Term)&gt;? entries);
      Bindings fromBindings(Bindings bindings);
    };
    </pre>

    <p>
      <dfn>bindings()</dfn> returns a new <code>Bindings</code> using the given entries,
      where the entries are represented as an array of key-value pairs.
    </p>    
    <p>
      <dfn>fromBindings()</dfn> returns a copy of the given <code>Bindings</code> using this factory.
    </p>
  </section>

</section>

  <div class="warning" title="Experimental!">
    <p>
      The following interfaces are experimental and will change in future versions of this document:
    </p>
    <p>
      <code>FilterableSource</code>, <code>FilterResult</code>, <code>QueryResultMetadata</code>, <code>QueryResultMetadataCount</code>, <code>QueryResultMetadataOptions</code>, <code>Expression</code>, <code>OperatorExpression</code>, <code>TermExpression</code>, <code>ExpressionFactory</code>
    </p>
  </div>

<section>
  <h2>Filter expression interfaces</h2>
  
  This section introduces interfaces that enable quad sources to be filtered based on a declarative expression.
  
  <section>
    <h2>Goals</h2>
    <ul>
      <li>Query engines MUST be able to push down filters into sources.</li>
      <li>Query engines MUST be able to detect what expressions are supported by sources.</li>
      <li>Query engines MUST be able to obtain the estimated cardinality of any supported expression.</li>
    </ul>
  </section>

  <section data-dfn-for="FilterableSource">
    <h3><dfn>FilterableSource</dfn> interface</h3>

    <pre class="idl">
    interface FilterableSource {
      FilterResult matchExpression (
        optional Term? subject,
        optional Term? predicate,
        optional Term? obj,
        optional Term? graph,
        optional Expression? expression
      );
    };
    </pre>
    
    <p>
      A <code>FilterableSource</code> is an object that produces a <code>FilterableSourceResult</code> that can emit quads.
      The emitted quads can be directly contained in this <code>FilterableSource</code> object, or they can be generated on the fly.
    </p>
    <p>
      <code>FilterableSource</code> is not necessarily an extension of the <a href="https://rdf.js.org/stream-spec/#source-interface">RDF/JS Source interface</a>, but implementers MAY decide to implement both at the same time.
    </p>
    <p>
      <dfn>matchExpression()</dfn> Returns a <code>FilterableSourceResult</code> that contains a quad stream that processes all quads matching the quad pattern and the expression.
    </p>
    <p>
      When a <code>Term</code> parameter is defined, and is a <code>NamedNode</code>, <code>Literal</code> or <code>BlankNode</code>,
      it must match each produced quad, according to the <a href="http://rdf.js.org/data-model-spec/#quad-interface"><code>Quad.equals</code></a> semantics.
      When a <code>Term</code> parameter is a <code>Variable</code>,
      or it is undefined, it acts as a wildcard, and can match with any <code>Term</code>.
    </p>
    <p class="note">
      When matching with <code>graph</code> set to <code>undefined</code> or <code>null</code>
      it MUST match all the graphs (sometimes called <em>the union graph</em>). To match only <em>the default graph</em>
      set <code>graph</code> to a <code>DefaultGraph</code>
    </p>
    <p>
      When an <code>Expression</code> parameter is defined, the complete quad stream is filtered according to this expression.
      When it is undefined, no filter is applied.
    </p>
    <p>
      If parameters of type <code>Variable</code> with an equal variable name are in place,
      then the corresponding quad components in the resulting quad stream MUST be equal.
    </p>
    <p>
      <code>Expression</code>'s MAY contain <code>Variable</code> <code>Term</code>'s.
      If their variable names are equal to <code>Variable</code>'s in the given quad pattern,
      then the <code>Expression</code> MUST be instantiated for each variable's binding in the resulting quad stream when applying the <code>Expression</code> filter.
    </p>
  </section>
  
  <section data-dfn-for="FilterResult">
    <h3><dfn>FilterResult</dfn> interface</h3>

    <pre class="idl">
    interface FilterResult {
      Stream quads();
      Promise&lt;QueryResultMetadata&gt; metadata(optional QueryResultMetadataOptions? options);
      Promise&lt;boolean&gt; isSupported();
    };
    </pre>
    
    <p>
      A <code>FilterResult</code> is an object that represents the result of a filter expression of <code>FilterableSource</code> for a given quad pattern and expression.
      It MAY create results lazily after one of its methods is invoked.
    </p>
    <p>
      <dfn>quads()</dfn> Returns a <a href="https://rdf.js.org/stream-spec/#stream-interface"><code>Stream<Quad></code></a> containing all the quads that matched the given quad pattern and expression.
    </p>
    <p>
      <dfn>metadata()</dfn> Asynchronously returns a <code>QueryResultMetadata</code>, that contains the metadata of the current result.
    </p>
    <p>
      <dfn>isSupported()</dfn> Asynchronously returns a boolean indicating if the requested expression is supported by the <code>FilterableSource</code>.
      If it returns <code>true</code>, <code>quads()</code> and <code>metadata()</code> MAY produce a valid result.
      If it returns <code>false</code>, <code>quads()</code> MUST return a stream emitting an error, and <code>metadata()</code> MUST reject.
    </p>
  </section>
  
  <section data-dfn-for="QueryResultMetadata">
    <h3><dfn>QueryResultMetadata</dfn> interface</h3>

    <pre class="idl">
    interface QueryResultMetadata {
      attribute QueryResultMetadataCount? count;
    };
    </pre>
    
    <p>
      A <code>QueryResultMetadata</code> is an object that represents contains metadata bout a certain query result,
      such as invoking <code>FilterableSource.matchExpression</code>.
    </p>
    <p>
      <dfn>count</dfn> is an optional field that contains metadata about the number of quads in the result stream.
    </p>
  </section>
  
  <section data-dfn-for="QueryResultMetadataCount">
    <h3><dfn>QueryResultMetadataCount</dfn> interface</h3>

    <pre class="idl">
    interface QueryResultMetadataCount {
      attribute string type;
      attribute number value;
    };
    </pre>
    
    <p>
      <code>QueryResultMetadataCount</code> is part of the <code>QueryResultMetadata</code> interface
      to represent metadata about the number of quads in the result stream.
    </p>
    <p>
      <dfn>type</dfn> indicates the type of counting that was done, and MUST either be <code>"estimate"</code> or <code>"exact"</code>.
    </p>
    <p>
      <dfn>value</dfn> indicates an estimate of the number of quads in the stream if <code>type = "estimate"</code>,
      or the exact number  of quads in the stream if <code>type = "exact"</code>.
    </p>
  </section>
  
  <section data-dfn-for="QueryResultMetadata">
    <h3><dfn>QueryResultMetadataOptions</dfn> interface</h3>

    <pre class="idl">
    interface QueryResultMetadataOptions {
      attribute string? count;
    };
    </pre>
    
    <p>
      A <code>QueryResultMetadataOptions</code> is an object that gives suggestions on what type of metadata is desired,
      such as when invoking <code>FilterResult.metadata</code>.
    </p>
    <p>
      <dfn>count</dfn> is an optional field that MAY either contain <code>"estimate"</code> or <code>"exact"</code>.
      If defined, this type MUST correspond to the type in <code>QueryResultMetadataCount</code>.
    </p>
  </section>
  
  <section data-dfn-for="Expression">
    <h3><dfn>Expression</dfn> interface</h3>

    <pre class="idl">
    interface Expression {
      attribute string expressionType;
    };
    </pre>
    
    <p>
      <code>QueryResultMetadataOptions</code> is an abstract interface that represents a generic expression over a stream of quads.
    </p>
    <p>
      <dfn>expressionType</dfn> contains a value that identifies the concrete interface of the expression, since the Expression itself is not directly instantiated.
      Possible values include <code>"operator"</code> and <code>"term"</code>.
    </p>
  </section>
  
  <section data-dfn-for="OperatorExpression">
    <h3><dfn>OperatorExpression</dfn> interface</h3>

    <pre class="idl">
    interface OperatorExpression {
      attribute string expressionType;
      attribute string operator;
      attribute FrozenArray&lt;Expression&gt; args;
    };
    </pre>
    
    <p>
      An <code>OperatorExpression</code> is represents an expression that applies a given operator on given sub-expressions.
    </p>
    <p>
      <dfn>expressionType</dfn> contains the constant <code>"operator"</code>.
    </p>
    <p>
      <dfn>operator</dfn> contains a value that identifies an operator.
      Possible values can be found in <a href="#expression-operators">the list of operators</a>.
    </p>
    <p>
      <dfn>args</dfn> contains an array of <code>Expression</code>'s on to which the given operator applies.
      The length of this array depends on the operator.
    </p>
  </section>
  
  <section data-dfn-for="TermExpression">
    <h3><dfn>TermExpression</dfn> interface</h3>

    <pre class="idl">
    interface TermExpression {
      attribute string expressionType;
      attribute Term term;
    };
    </pre>
    
    <p>
      A <code>TermExpression</code> is an expression that contains a <a href="http://rdf.js.org/data-model-spec/#term-interface"><code>Term</code></a>.
    </p>
    <p>
      <dfn>expressionType</dfn> contains the constant <code>"term"</code>.
    </p>
    <p>
      <dfn>term</dfn> contains a <a href="http://rdf.js.org/data-model-spec/#term-interface"><code>Term</code></a>.
    </p>
  </section>
  
  <section data-dfn-for="ExpressionFactory">
    <h3><dfn>ExpressionFactory</dfn> interface</h3>

    <pre class="idl">
    interface ExpressionFactory {
      OperatorExpression operatorExpression(string operator, sequence&lt;Expression&gt; args);
      TermExpression termExpression(Term term);
    };
    </pre>
    
    <p>
      <code>ExpressionFactory</code> enables expressions to be created in an idiomatic manner.
    </p>
    <p>
      <dfn>operatorExpression</dfn> creates a new <code>OperatorExpression</code> instance for the given operator and array of arguments.
    </p>
    <p>
      <dfn>termExpression</dfn> creates a new <code>TermExpression</code> instance for the given term.
    </p>
  </section>

</section>

<section>
  <h2>Expression operators</h2>

  <p>This section introduces a non-exhaustive list of operators that MAY be used in <code>OperatorExpression</code>.</p>

  <p>Implementers MAY decide to support only a subset of these operators.</p>
  
  <p>We omit any formal semantics behind these operators in this specification, and refer to their <a href="https://www.w3.org/TR/sparql11-query/">SPARQL 1.1. semantics</a>.</p>
  
  <section>
    <h2>Relational operators</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#OperatorMapping">relational operators</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><code>!</code></td>
          <td>
            <ol>
              <li><code>Literal (xsd:boolean)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>The inverse of the given boolean value.</td>
        </tr>
        <tr>
          <td><code>uplus</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The positive value of the given numeric value.</td>
        </tr>
        <tr>
          <td><code>uminus</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The negative value of the given numeric value.</td>
        </tr>
        <tr>
          <td><code>*</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The multiplication of the given values.</td>
        </tr>
        <tr>
          <td><code>/</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The division of the given values.</td>
        </tr>
        <tr>
          <td><code>+</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The addition of the given values.</td>
        </tr>
        <tr>
          <td><code>-</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The subtraction of the given values.</td>
        </tr>
        <tr>
          <td><code>=</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the given values are equal. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>!=</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the given values are not equal. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&lt;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is lesser than the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&gt;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is greater than the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&le;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is lesser than or equal to the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&ge;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is greater than or equal to the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>Term functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-rdfTerms">functions on RDF terms</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isIRI"><code>isiri</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>NamedNode</code>. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isBlank"><code>isblank</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>BlankNode</code>. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isLiteral"><code>isliteral</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>Literal</code>. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isNumeric"><code>isnumeric</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>Literal</code> with a numeric datatype. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-str"><code>str</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the (lexical) string representation of the given term.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-lang"><code>lang</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the language tag of the given <code>Literal</code>, or the empty string if the <code>Literal</code> has no language tag.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-datatype"><code>datatype</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code></li>
            </ol>
          </td>
          <td><code>NamedNode</code></td>
          <td>Returns the datatype of the given <code>Literal</code>.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-iri"><code>iri</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string), <code>NamedNode</code></li>
            </ol>
          </td>
          <td><code>NamedNode</code></td>
          <td>Resolve the given IRI against the base IRI of the current context.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-bnode"><code>bnode</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string), <em>empty</em></li>
            </ol>
          </td>
          <td><code>BlankNode</code></td>
          <td>Create a new blank node with the given label if provided.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strdt"><code>strdt</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string)</li>
              <li><code>NamedNode</code></li>
            </ol>
          </td>
          <td><code>Literal</code></td>
          <td>Returns a new <code>Literal</code> with the given datatype.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strlang"><code>strlang</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string)</li>
              <li><code>Literal</code> (xsd:string)</li>
            </ol>
          </td>
          <td><code>Literal</code></td>
          <td>Returns a new <code>Literal</code> with the given language tag.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-uuid"><code>uuid</code></a></td>
          <td>/</td>
          <td><code>NamedNode</code></td>
          <td>Returns a new <code>NamedNode</code> following the <a href="https://www.ietf.org/rfc/rfc4122.txt">UUID URN scheme</a>.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-struuid"><code>struuid</code></a></td>
          <td>/</td>
          <td><code>Literal</code> (xsd:string)</td>
          <td>Returns a new <code>Literal</code> following the <a href="https://www.ietf.org/rfc/rfc4122.txt">UUID URN scheme</a>.</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>String functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-strings">string functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strlen"><code>strlen</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the number of characters of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-substr"><code>substr</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:integer)</code></li>
              <li><code>Literal (xsd:integer)</code> (optional)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the substring of the given string starting from the given position (second parameter) with the given length (third parameter). If no third parameter is provided, then the maximum length is taken.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-ucase"><code>ucase</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Transform each character in the given string to upper case.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-lcase"><code>lcase</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Transform each character in the given string to lower case.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strstarts"><code>strstarts</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if the given string starts with the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strends"><code>strends</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if the given string ends with the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strcontains"><code>strcontains</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if the given string contains the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strbefore"><code>strbefore</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>From the given first string, find the full string that occurs before the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strafter"><code>strafter</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>From the given first string, find the full string that occurs after the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-encode"><code>encode_for_uri</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Apply URI encoding on the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-concat"><code>concat</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li> (variable number of arguments)
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Concatenation of all the given strings.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-langMatches"><code>langmatches</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the language tag of the first literal matches the second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-regex"><code>regex</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code> (optional)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if on the given first string, the given second regular expression matches. The third parameter indicates optional regex flags.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-replace"><code>replace</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code> (optional)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>In the given first string, match the given second regular expression, and replace it with the given third string. The fourth parameter indicates optional regex flags.</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>Numerical functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-numerics">numerical functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-abs"><code>abs</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the absolute value of the given numerical term.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-round"><code>round</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the number with no fractional part that is closest to the argument, with preference for rounding up.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-ceil"><code>ceil</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the smallest (closest to negative infinity) number with no fractional part that is not less than the value of arg.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-floor"><code>floor</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the largest (closest to positive infinity) number with no fractional part that is not greater than the value of arg.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-rand"><code>rand</code></a></td>
          <td>
            /
          </td>
          <td><code>Literal (xsd:double)</code></td>
          <td>Returns a pseudo-random, number between 0 (inclusive) and 1.0e0 (exclusive). Different numbers can be produced every time this function is invoked. Numbers should be produced with approximately equal probability.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Date and time functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-date-time">date and time functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-now"><code>now</code></a></td>
          <td>
            /
          </td>
          <td><code>Literal (xsd:dateTime)</code></td>
          <td>Returns an XSD dateTime value for the current query execution. All calls to this function in any one query execution must return the same value.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-year"><code>year</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the year of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-month"><code>month</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the month of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-day"><code>day</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the day of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-hours"><code>hours</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the hours of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-minutes"><code>minutes</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the minutes of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-seconds"><code>seconds</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the seconds of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-timezone"><code>timezone</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:dayTimeDuration)</code></td>
          <td>Returns the timezone part of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-tz"><code>tz</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the timezone part of the given date.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Hash functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-hash">hash functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-md5"><code>md5</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the MD5 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha1"><code>sha1</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA1 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha256"><code>sha256</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA256 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha384"><code>sha384</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA384 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha512"><code>sha512</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA512 checksum of the given string.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>XPath constructor functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#FunctionMapping">XPath constructor functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#string</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Cast the given term to <code>xsd:string</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#float</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:float)</code></td>
          <td>Cast the given term to <code>xsd:float</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#double</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:double)</code></td>
          <td>Cast the given term to <code>xsd:double</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#decimal</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:decimal)</code></td>
          <td>Cast the given term to <code>xsd:decimal</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#integer</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Cast the given term to <code>xsd:integer</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#dateTime</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:dateTime)</code></td>
          <td>Cast the given term to <code>xsd:dateTime</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#date</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:date)</code></td>
          <td>Cast the given term to <code>xsd:date</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#boolean</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Cast the given term to <code>xsd:boolean</code></td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>Functional forms</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-forms">functional operators</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-bound"><code>bound</code></a></td>
          <td>
            <ol>
              <li><code>Variable</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if the given variable is bound to a value. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-if"><code>if</code></a></td>
          <td>
            <ol>
              <li><code>Expression</code></li>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Term</code></td>
          <td>Evaluates the expression as <a href="https://www.w3.org/TR/sparql11-query/#ebv">effective boolean value</a>. Returns the second argument if true, otherwise the third argument.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-coalesce"><code>coalesce</code></a></td>
          <td>
            <ol>
              <li><code>Expression</code> (variable number of arguments)</li>
            </ol>
          </td>
          <td><code>Term</code></td>
          <td>Returns the first expression result that evaluates without an error.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-or"><code>||</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:boolean)</code></li>
              <li><code>Literal (xsd:boolean)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns a logical OR of left and right. Note that logical-or operates on the <a href="https://www.w3.org/TR/sparql11-query/#ebv">effective boolean value</a> of its arguments.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-and"><code>&amp;&amp;</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:boolean)</code></li>
              <li><code>Literal (xsd:boolean)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns a logical AND of left and right. Note that logical-or operates on the <a href="https://www.w3.org/TR/sparql11-query/#ebv">effective boolean value</a> of its arguments.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal"><code>=</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if both terms are the same follow these <a href="https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal">rules</a>. A type error is produced if both arguments are literals but not the same.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sameTerm"><code>sameterm</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if both terms are the same follow these <a href="https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal">rules</a>. False is returned instead of type errors.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-in"><code>in</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Expression</code> (variable number of arguments)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Tests whether the RDF term on the left-hand side is found in the values of list of expressions on the right-hand side.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-not-in"><code>notin</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Expression</code> (variable number of arguments)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Tests whether the RDF term on the left-hand side is not found in the values of list of expressions on the right-hand side.</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>

</body>
</html>
