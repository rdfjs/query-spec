<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>RDF/JS: Query specification</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c-common" class="remove"></script>
  <script class="remove">
    var respecConfig = {
      specStatus: "CG-DRAFT",
      shortName: "rdfjs",
      subtitle: "RDF/JS: Query specification",
      processVersion: 2020,
      edDraftURI: "https://github.com/rdfjs/query-spec/",
      issueBase: "https://github.com/rdfjs/query-spec/issues/",
      githubAPI: "https://api.github.com/repos/rdfjs/query-spec",
      // TODO: testSuiteURIkey: "",
      editors: [
          {
            name: "Ruben Taelman",
            url: "https://www.rubensworks.net/#me",
            company: "Ghent University – imec",
            companyURL: "http://idlab.ugent.be/",
            w3cid: 84199
          },
          {
            name: "Jacopo Scazzosi",
            url: "https://jacoscaz.com/#me",
            company: "Beautiful Interactions s.r.l.",
            companyURL: "https://beautifulinteractions.com/",
            w3cid: 72858
          }
      ],
      authors:  [
          {
            name: "Ruben Taelman",
            url: "https://www.rubensworks.net/#me",
            company: "Ghent University – imec",
            companyURL: "http://idlab.ugent.be/",
            w3cid: 84199
          },
          {
            name: "Jacopo Scazzosi",
            url: "https://jacoscaz.com/#me",
            company: "Beautiful Interactions s.r.l.",
            companyURL: "https://beautifulinteractions.com/",
            w3cid: 72858
          }
      ],
      bugTracker:             {
        open: "https://github.com/rdfjs/query-spec/issues?utf8=%E2%9C%93&q=is%3Aissue%20is%3Aopen%20",
        new:  "https://github.com/rdfjs/query-spec/issues/new"
      },
      otherLinks: [{
        key: "Version control",
        data: [{
          value: "Github Repository",
          href: "https://github.com/rdfjs/query-spec"
        }]
      }],
      wg: "RDF JavaScript Libraries Community Group",
      wgURI: "https://www.w3.org/community/rdfjs/",
      wgPublicList: "public-rdfjs",
      maxTocLevel: 2
    };
  </script>
</head>
<body>
<section id="abstract">
  <h2>Abstract</h2>
  <p>
    The scope of this specification is to provide a way to query over RDF quads in JavaScript, as defined in the <a href="http://rdf.js.org/data-model-spec/#quad-interface">RDF/JS: Data model specification</a>.
    It contains high-level interfaces for libraries that want to expose querying capabilities,
    and low-level interfaces for working across query engine components.
  </p>
</section>

<section id="sotd">
  <p>
    This document provides a specification of an interface for RDF query engines in a JavaScript environment.
	The task force which defines this interface was formed by RDF JavaScript library developers with the wish to make existing
    and future libraries interoperable. This definition strives to provide the minimal necessary
    interface to enable interoperability of RDF querying libraries.
  </p>
  <p>
    <strong>Currently, this specification provides high-level interfaces such as <code>Queryable</code> for exposing querying capabilities,
    and low-level interfaces such as <code>FilterableSource</code> for interoperability across query engines.</strong>
  </p>
</section>

<section>
  <h2>Design elements and principles</h2>
  <ul>
    <li><em>All <a href="http://rdf.js.org/data-model-spec/#design-elements-and-principles">design elements and principles from the RDF/JS data model specification</a> apply here as well.</em></li>
    <li>Interfaces do not conflict with other RDF/JS interfaces, and users and implementers of purely other RDF/JS interfaces should not be aware of the interfaces in this specification if they are not needed.</li>
    <li>Data interfaces should not contain methods, as to enable straightforward transmission over low-level communication protocols such as Web Assembly.</li>
    <li>To enable querying over large graphs, interfaces should handle quads in a streaming manner, such as the <a href="https://rdf.js.org/stream-spec/">RDF/JS stream interfaces</a>.</li>
  </ul>
</section>

<section>
  <h2>SPARQL Queryable interfaces</h2>
  
  This section introduces queryable interfaces that can be implemented by SPARQL-constrained query engines.
  These interfaces guarantees that result objects are of the expected type as defined by the SPARQL spec,
  and is often more convenient to use compared to the general queryable interfaces.

  <section data-dfn-for="StringSparqlQueryable">
    <h3><dfn>StringSparqlQueryable</dfn> interface</h3>

    <pre class="idl">
    interface StringSparqlQueryable {
      optional Promise&lt;Stream&lt;Bindings&gt;&gt; queryBindings(String query, QueryStringContext? context);
      optional Promise&lt;Stream&lt;Quad&gt;&gt; queryQuads(String query, QueryStringContext? context);
      optional Promise&lt;boolean&gt; queryBoolean(String query, QueryStringContext? context);
      optional Promise&lt;void&gt; queryVoid(String query, QueryStringContext? context);
    };
    </pre>

    <p>
      A <code>StringSparqlQueryable</code> can be implemented by objects that want to expose a SPARQL-constrained query execution interface
      that accepts queries as a string.
    </p>
    <p>
      <dfn>queryBindings()</dfn> is an optional method that asynchronously returns a <code>Stream</code> of <code>Bindings</code> objects.
      <dfn>query</dfn> is a query string that SHOULD be a SPARQL <code>SELECT</code> query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
    <p>
      <dfn>queryQuads()</dfn> is an optional method that asynchronously returns a <code>Stream</code> of <code>Quad</code> objects.
      <dfn>query</dfn> is a query string that SHOULD be a SPARQL <code>CONSTRUCT</code> or <code>DESCRIBE</code> query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
    <p>
      <dfn>queryBoolean()</dfn> is an optional method that asynchronously returns a <code>boolean</code>.
      <dfn>query</dfn> is a query string that SHOULD be a SPARQL <code>ASK</code> query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
    <p>
      <dfn>queryVoid()</dfn> is an optional method that asynchronously returns a <code>void</code>.
      <dfn>query</dfn> is a query string that SHOULD be a SPARQL update query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
  </section>
  
  <section data-dfn-for="AlgebraSparqlQueryable">
    <h3><dfn>AlgebraSparqlQueryable</dfn> interface</h3>

    <pre class="idl">
    interface AlgebraSparqlQueryable {
      optional Promise&lt;Stream&lt;Bindings&gt;&gt; queryBindings(Algebra query, QueryStringContext? context);
      optional Promise&lt;Stream&lt;Quad&gt;&gt; queryQuads(Algebra query, QueryStringContext? context);
      optional Promise&lt;boolean&gt; queryBoolean(Algebra query, QueryStringContext? context);
      optional Promise&lt;void&gt; queryVoid(Algebra query, QueryStringContext? context);
    };
    </pre>

    <p>
      An <code>AlgebraSparqlQueryable</code> can be implemented by objects that want to expose a query execution interface that accepts queries as an <code>Algebra</code> object.
    </p>
    <p>
      <dfn>queryBindings()</dfn> is an optional method that asynchronously returns a <code>Stream</code> of <code>Bindings</code> objects.
      <dfn>query</dfn> is a query <code>Algebra</code> object that SHOULD be a SPARQL <code>SELECT</code> query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
    <p>
      <dfn>queryQuads()</dfn> is an optional method that asynchronously returns a <code>Stream</code> of <code>Quad</code> objects.
      <dfn>query</dfn> is a query <code>Algebra</code> object that SHOULD be a SPARQL <code>CONSTRUCT</code> or <code>DESCRIBE</code> query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
    <p>
      <dfn>queryBoolean()</dfn> is an optional method that asynchronously returns a <code>boolean</code>.
      <dfn>query</dfn> is a query <code>Algebra</code> object that SHOULD be a SPARQL <code>ASK</code> query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
    <p>
      <dfn>queryVoid()</dfn> is an optional method that asynchronously returns a <code>void</code>.
      <dfn>query</dfn> is a query <code>Algebra</code> object that SHOULD be a SPARQL update query.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
  </section>

</section>

<section>
  <h2>Queryable interfaces</h2>
  
  This section introduces interfaces that can be implemented by query engines to make them expose a query execution interface.

  <section data-dfn-for="StringQueryable">
    <h3><dfn>StringQueryable</dfn> interface</h3>

    <pre class="idl">
    interface StringQueryable {
      Promise&lt;Query&gt; query(String query, QueryStringContext? context);
    };
    </pre>

    <p>
      A <code>StringQueryable</code> can be implemented by objects that want to expose a query execution interface that accepts queries as a string.
    </p>
    <p>
      <dfn>query()</dfn> asynchronously returns a new <code>Query</code> object that can be executed later.
      <dfn>query</dfn> is a query string.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
  </section>
  
  <section data-dfn-for="AlgebraQueryable">
    <h3><dfn>AlgebraQueryable</dfn> interface</h3>

    <pre class="idl">
    interface AlgebraQueryable {
      Promise&lt;Query&gt; query(Algebra query, QueryAlgebraContext? context);
    };
    </pre>

    <p>
      An <code>AlgebraQueryable</code> can be implemented by objects that want to expose a query execution interface that accepts queries as an <code>Algebra</code> object.
    </p>
    <p>
      <dfn>query()</dfn> asynchronously returns a new <code>Query</code> object that can be executed later.
      <dfn>query</dfn> is a query <code>Algebra</code> object.
      <dfn>context</dfn> is an optional context in which query execution options can be passed.
    </p>
  </section>

</section>

<section>
  <h2>Query interfaces</h2>
  
  This section introduces query interfaces that act as intermediary objects that represent queries that can be executed.
  
  <section data-dfn-for="Query">
    <h3><dfn>Query</dfn> interface</h3>
    <pre class="idl">
    interface Query {
      readonly attribute string resultType;
      Promise&lt;any&gt; execute(any options);
    };
    </pre>

    <p>
      <code>Query</code> is an abstract interface that represents a query that can be executed.
    </p>

    <p>
      <dfn>resultType</dfn> represents the type of query that is being executed.
      Possible values include <code>"bindings"</code>, <code>"quads"</code>, <code>"boolean"</code>, and <code>"void"</code>.
    </p>
    <p>
      <dfn>execute()</dfn> asynchronously returns the query result, where the signature depends on the <code>resultType</code>.
    </p>
  </section>
  
  <section data-dfn-for="QueryBindings">
    <h3><dfn>QueryBindings</dfn> interface</h3>
    <pre class="idl">
    interface QueryBindings {
      readonly attribute string resultType;
      Promise&lt;Stream&lt;Bindings&gt;&gt; execute(QueryExecuteOptions&lt;Variable&gt;? options);
      Promise&lt;QueryMetadata&lt;Bindings&gt;&gt; metadata(QueryMetadataOptions? options);
    };
    </pre>

    <p>
      <code>QueryBindings</code> represents a query that returns a stream of <code>Bindings</code>, such as a SPARQL <code>SELECT</code> query.
    </p>

    <p>
      <dfn>resultType</dfn> contains the constant <code>"bindings"</code>.
    </p>
    <p>
      <dfn>execute()</dfn> asynchronously returns the a stream of <code>Bindings</code>.
      <dfn>options</dfn> is an optional argument in which execution options can be passed.
    </p>
    <p>
      <dfn>metadata()</dfn> asynchronously returns the a <code>QueryMetadata</code> object.
      <dfn>options</dfn> is an optional argument in which desired metadata options can be passed.
    </p>
  </section>
  
  <section data-dfn-for="QueryQuads">
    <h3><dfn>QueryQuads</dfn> interface</h3>
    <pre class="idl">
    interface QueryQuads {
      readonly attribute string resultType;
      Promise&lt;Stream&lt;Quad&gt;&gt; execute(QueryExecuteOptions&lt;("subject" or "predicate" or "object" or "graph")&gt;? options);
      Promise&lt;QueryMetadata&lt;Quad&gt;&gt; metadata(QueryMetadataOptions? options);
    };
    </pre>

    <p>
      <code>QueryQuads</code> represents a query that returns a stream of <code>Quad</code>s, such as a SPARQL <code>CONSTRUCT</code> or <code>DESCRIBE</code> query.
    </p>

    <p>
      <dfn>resultType</dfn> contains the constant <code>"quads"</code>.
    </p>
    <p>
      <dfn>execute()</dfn> asynchronously returns the a stream of <code>Quad</code>s.
      <dfn>options</dfn> is an optional argument in which execution options can be passed.
    </p>
    <p>
      <dfn>metadata()</dfn> asynchronously returns the a <code>QueryMetadata</code> object.
      <dfn>options</dfn> is an optional argument in which desired metadata options can be passed.
    </p>
  </section>
  
  <section data-dfn-for="QueryBoolean">
    <h3><dfn>QueryBoolean</dfn> interface</h3>
    <pre class="idl">
    interface QueryBoolean {
      readonly attribute string resultType;
      Promise&lt;boolean&gt; execute();
    };
    </pre>

    <p>
      <code>QueryBoolean</code> represents a query that returns a <code>boolean</code>, such as a SPARQL <code>ASK</code> query.
    </p>

    <p>
      <dfn>resultType</dfn> contains the constant <code>"boolean"</code>.
    </p>
    <p>
      <dfn>execute()</dfn> asynchronously returns a <code>boolean</code>.
    </p>
  </section>
  
  <section data-dfn-for="QueryVoid">
    <h3><dfn>QueryVoid</dfn> interface</h3>
    <pre class="idl">
    interface QueryVoid {
      readonly attribute string resultType;
      Promise&lt;void&gt; execute();
    };
    </pre>

    <p>
      <code>QueryVoid</code> represents a query that returns nothing, such as a SPARQL update query.
    </p>

    <p>
      <dfn>resultType</dfn> contains the constant <code>"void"</code>.
    </p>
    <p>
      <dfn>execute()</dfn> asynchronously returns nothing.
    </p>
  </section>
  
  <section data-dfn-for="QueryExecuteOptions">
    <h3><dfn>QueryExecuteOptions</dfn> interface</h3>
    <pre class="idl">
    interface QueryExecuteOptions&lt;OrderType&gt; {
      readonly attribute Array&lt;QueryOperationOrderTerm&lt;OrderType&gt;&gt; order;
    };
    </pre>

    <p>
      <code>QueryExecuteOptions</code> represents the options for executing a query.
    </p>

    <p>
      <dfn>order</dfn> contains the desired order of query results.
    </p>
  </section>
  
  <section data-dfn-for="QueryMetadataOptions">
    <h3><dfn>QueryMetadataOptions</dfn> interface</h3>
    <pre class="idl">
    interface QueryMetadataOptions {
      attribute ("estimate" or "exact")? cardinality;
      attribute boolean order;
      attribute boolean availableOrders;
    };
    </pre>

    <p>
      <code>QueryMetadataOptions</code> represents the options for requesting the metadata of a query.
    </p>

    <p>
      <dfn>cardinality</dfn> indicates if an exact or estimated value for the <code>cardinality</code> metadata field should be returned.
    </p>
    <p>
      <dfn>order</dfn> indicates if the <code>order</code> metadata field should be returned.
    </p>
    <p>
      <dfn>availableOrders</dfn> indicates if the <code>availableOrders</code> metadata field should be returned.
    </p>
  </section>
  
</section>

<section>
  <h2>Metadata interfaces</h2>
  
  This section introduces metadata interfaces that can contain additional information about the query execution process.
  
  <section data-dfn-for="QueryMetadata">
    <h3><dfn>QueryMetadata</dfn> interface</h3>
    <pre class="idl">
    interface QueryMetadata&lt;OrderType&gt; {
      readonly attribute QueryResultCardinality? cardinality;
      readonly attribute Array&lt;QueryOperationOrderTerm&lt;OrderType&gt;&gt;? order;
      readonly attribute Array&lt;QueryResultOrderCost&lt;OrderType&gt;&gt;? availableOrders;
    };
    </pre>

    <p>
      <code>QueryMetadata</code> is an interface that contains side information about the query execution process.
    </p>

    <p>
      <dfn>cardinality</dfn> represents the number of results of a query.
    </p>
    <p>
      <dfn>order</dfn> represents the order of results in the query result.
    </p>
    <p>
      <dfn>availableOrders</dfn> is an array of alternative orders that may be requested when executing a query.
    </p>
  </section>
  
  <section data-dfn-for="QueryResultCardinality">
    <h3><dfn>QueryResultCardinality</dfn> interface</h3>
    <pre class="idl">
    interface QueryResultCardinality {
      attribute ("estimate" or "exact") type;
      attribute unsigned long value;
    };
    </pre>

    <p>
      <code>QueryResultCardinality</code> represents the number of results of a query, which can either be an estimated value or exact.
    </p>

    <p>
      <dfn>type</dfn> contains the value <code>"estimate"</code> or <code>"exact"</code>,
      which respectively refer to an exact or estimate value.
    </p>
    <p>
      <dfn>value</dfn> contains the cardinality value.
    </p>
  </section>

  <section data-dfn-for="QueryOperationOrderTerm">
    <h3><dfn>QueryOperationOrderTerm</dfn> interface</h3>
    <pre class="idl">
    interface QueryOperationOrderTerm&lt;OrderType&gt; {
      attribute OrderType term;
      attribute ("asc" or "desc") direction;
    };
    </pre>

    <p>
      <code>QueryOperationOrderTerm</code> represents the ordering of a term of a given generic type.
    </p>

    <p>
      <dfn>term</dfn> contains the term over which the order is applied.
    </p>
    <p>
      <dfn>direction</dfn> contains the value <code>"asc"</code> or <code>"desc"</code>,
      which respectively refer to an ascending or descending order.
    </p>
  </section>

  <section data-dfn-for="QueryResultOrderCost">
    <h3><dfn>QueryResultOrderCost</dfn> interface</h3>
    <pre class="idl">
    interface QueryResultOrderCost&lt;OrderType&gt; {
      attribute QueryOperationCost cost;
      attribute Array&lt;QueryOperationOrderTerm&lt;OrderType&gt;&gt; terms;
    };
    </pre>

    <p>
      <code>QueryResultOrderCost</code> represents the cost of a specific ordering of query results.
    </p>

    <p>
      <dfn>cost</dfn> represents the cost of executing this ordering.
    </p>
    <p>
      <dfn>terms</dfn> represents the order of terms in an ordering.
    </p>
  </section>

  <section data-dfn-for="QueryOperationCost">
    <h3><dfn>QueryOperationCost</dfn> interface</h3>
    <pre class="idl">
    interface QueryOperationCost {
      attribute unsigned long iterations;
      attribute unsigned long persistedItems;
      attribute unsigned long blockingItems;
      attribute unsigned long requestTime;
    };
    </pre>

    <p>
      <code>QueryOperationCost</code> represents the cost of a certain query operation.
    </p>

    <p>
      <dfn>iterations</dfn> is estimation of how many iterations over items are executed. This can be used to determine the CPU cost.
    </p>
    <p>
      <dfn>persistedItems</dfn> is estimation of how many items are stored in memory. This is used to determine the memory cost.
    </p>
    <p>
      <dfn>blockingItems</dfn> is estimation of how many items block the stream. This is used to determine the time the stream is not progressing anymore.
    </p>
    <p>
      <dfn>requestTime</dfn> is estimation of the time to request items from sources. This is used to determine the I/O cost.
    </p>
  </section>
</section>

<section>
  <h2>Query context interfaces</h2>
  
  This section introduces interfaces related to query contexts,
  which are an optional argument to queryable interfaces for passing additional in information to query engines.
  
  <section data-dfn-for="QueryContext">
    <h3><dfn>QueryContext</dfn> interface</h3>
    <pre class="idl">
    interface QueryContext {
      attribute Date? queryTimestamp;
    };
    </pre>
    
    <p>
      <code>QueryContext</code> is a base context interface.
    </p>
    
    <p>
      <dfn>queryTimestamp</dfn> The date that should be used by SPARQL operations such as <code>NOW()</code>.
    </p>
  </section>
  
  <section data-dfn-for="QueryStringContext">
    <h3><dfn>QueryStringContext</dfn> interface</h3>
    <pre class="idl">
    interface QueryStringContext : QueryContext {
      attribute QueryFormat? queryFormat;
      attribute string? baseIRI;
    };
    </pre>
    
    <p>
      A <code>QueryStringContext</code> is a context that can be passed together with a query string.
    </p>
    
    <p>
      <dfn>queryFormat</dfn> The format in which the query string is defined.
    </p>
    <p>
      <dfn>baseIRI</dfn> The base IRI for parsing the query.
    </p>
  </section>
  
  <section data-dfn-for="QueryAlgebraContext">
    <h3><dfn>QueryAlgebraContext</dfn> interface</h3>
    <pre class="idl">
    interface QueryAlgebraContext : QueryContext {};
    </pre>
    
    <p>
      A <code>QueryAlgebraContext</code> is a context that can be passed together with a query <code>Algebra</code> object.
    </p>
    
  </section>
  
  <section data-dfn-for="QuerySourceContext">
    <h3><dfn>QuerySourceContext</dfn> interface</h3>
    <pre class="idl">
    interface QuerySourceContext : QueryContext {
      attribute Array? sources;
    };
    </pre>
    
    <p>
      A <code>QuerySourceContext</code> can be used by query engines that accept custom data sources during query execution.
    </p>
    
    <p>
      <dfn>sources</dfn> An array of data sources the query engine must use.
    </p>
  </section>
  
  <section data-dfn-for="QueryFormat">
    <h3><dfn>QueryFormat</dfn> interface</h3>
    <pre class="idl">
    interface QueryFormat {
      attribute string language;
      attribute string version;
      attribute Array&lt;string&gt;? extensions;
    };
    </pre>
    
    <p>
      A <code>QueryFormat</code> represents the format of a string query, and may influence parsing or execution behaviour.
    </p>
    
    <p>
      <dfn>language</dfn> The query language, e.g. <code>"sparql"</code>.
    </p>
    <p>
      <dfn>version</dfn> The version of the query language, e.g. <code>"1.1"</code>.
    </p>
    <p>
      <dfn>language</dfn> An optional array of extensions on the query language. The representation of these extensions is undefined.
    </p>
  </section>
  
</section>

<section>
  <h2>Bindings interfaces</h2>
  
  This section introduces interfaces related to query result bindings.
  In SPARQL SELECT queries, these bindings correspond to <a href="https://www.w3.org/TR/sparql11-query/#sparqlSolutions">solution mappings</a>.

  <section>
    <h2>Goals</h2>
    <ul>
      <li>Query engines should be able to interact with bindings created by different libraries.</li>
      <li>Bindings are immutable</li>
      <li>Interfaces do no specify how bindings are stored in memory</li>
    </ul>
  </section>
  
  <section data-dfn-for="Bindings">
    <h3><dfn>Bindings</dfn> interface</h3>

    <pre class="idl">
    interface Bindings {
      iterable&lt;(Variable, Term)&gt;;

      readonly attribute string type;
      readonly attribute unsigned long size;

      boolean has((Variable or string) key);
      Term? get((Variable or string) key);
      Bindings set((Variable or string) key, Term value);
      Bindings delete((Variable or string) key);
      iterable&lt;Variable&gt; keys();
      iterable&lt;Term&gt; values();
      boolean equals(optional Bindings? other);
      void forEach(BindingsEntryCallback callback);
      Bindings filter(BindingsFilterCallback callback);
      Bindings map(BindingsMapCallback callback);
      Bindings merge(Bindings other);
      Bindings mergeWith(BindingsMergeCallback callback, Bindings other);
    };
    
    callback BindingsEntryCallback = undefined (Term value, Variable key);
    callback BindingsFilterCallback = boolean (Term value, Variable key);
    callback BindingsMapCallback = Term (Term value, Variable key);
    callback BindingsMergeCallback = Term (Term self, Term other, Variable key);
    </pre>

    <p>
      A <code>Bindings</code> is an object that represents the mapping of variables to RDF values using an immutable Map-like representation.
      This means that methods such as <code>set</code> and <code>delete</code> do not modify this instance,
      but they return a new Bindings instance that contains the modification.
    </p>
    <p>
      Every <code>Bindings</code> object is an iterable over its entries, where each entry is a tuple of <code>Variable</code> key and <code>Term</code> value.
    </p>
    
    <h3>Attributes</h3>
    
    <p>
      <dfn>type</dfn> contains the constant <code>"bindings"</code>.
    </p>
    <p>
      <dfn>size</dfn> is a field that contains the number of entries in this <code>Bindings</code> object.
    </p>
    
    <h3>Methods</h3>
    
    <p>
      <dfn>has</dfn> checks if a binding exist for the given variable.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
    </p>
    <p>
      <dfn>get</dfn> returns the <code>Term</code> value bound to the given variable, or <code>undefined</code> if no binding exists.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
    </p>
    <p>
      <dfn>set</dfn> returns a new <code>Bindings</code> object by adding the given variable and value mapping.
      If the variable already exists in the binding, then the existing mapping is overwritten.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
      <dfn>value</dfn> is the <code>Term</code> value that must be bound.
    </p>
    <p>
      <dfn>delete</dfn> returns a new <code>Bindings</code> object by removing the given variable.
      If the variable does not exist in the binding, a copy of the <code>Bindings</code> object is returned.
      <dfn>key</dfn> can be a <code>Variable</code> or string. If it is a string, no `?` prefix must be given.
    </p>
    <p>
      <dfn>keys</dfn> returns an iterable of <code>Variable</code> instances for which mappings exist.
    </p>
    <p>
      <dfn>values</dfn> returns an iterable of <code>Term</code> values for which mappings exist.
    </p>
    <p>
      <dfn>equals</dfn> returns <code>true</code>
      when called with parameter <code>other</code>
      on an object <code>Bindings</code> if
      all of the conditions below hold:
    </p>
    <ul>
      <li><code>other</code> is <em>neither</em> <code>null</code> nor <code>undefined</code>;</li>
      <li>The keys in the this and the other <code>Bindings</code> object are equal (following the semantics of <code>Variable.equals</code>);</li>
      <li>For each key, the values within each <code>Bindings</code> object are equal (following the semantics of <code>Term.equals</code>);</li>
    </ul>
    <p>
      <dfn>forEach</dfn> invokes the <code>callback</code> for all entries in this <code>Bindings</code> object,
      with the entry value <code>Term</code> as first argument, and the entry key <code>Variable</code> as second argument.
    </p>
    <p>
      <dfn>filter</dfn> returns a new <code>Bindings</code> object by filtering entries using <code>callback</code>,
      with the entry value <code>Term</code> as first argument, and the entry key <code>Variable</code> as second argument.
      Returning <code>true</code> indicates that this entry must be contained in the resulting <code>Bindings</code> object.
    </p>
    <p>
      <dfn>map</dfn> returns a new <code>Bindings</code> object by mapping entries using <code>callback</code>,
      with the entry value <code>Term</code> as first argument, and the entry key <code>Variable</code> as second argument.
      The original <code>Term</code> value is replaced by the returned <code>Term</code> value in the resulting <code>Bindings</code> object.
    </p>
    <p>
      <dfn>merge</dfn> merges this <code>Bindings</code> object with another <code>Bindings</code> object.
      If a merge conflict occurs (this and other have an equal variable with unequal value), then <code>undefined</code> is returned.
    </p>
    <p>
      <dfn>mergeWith</dfn> merges this <code>Bindings</code> object with another <code>Bindings</code> object,
      where merge conflicts can be resolved using <code>callback</code>.
      <code>callback</code> is invoked with the value <code>Term</code> of the first <code>Bindings</code> object as first argument,
      the value <code>Term</code> of the second <code>Bindings</code> object as second argument,
      and the key <code>Variable</code> as third argument,
      where the returned <code>Term</code> is considered the merged value.
    </p>
  </section>

  <section data-dfn-for="BindingsFactory">
    <h3><dfn>BindingsFactory</dfn> interface</h3>

    <pre class="idl">
    interface BindingsFactory {
      Bindings bindings(Array&lt;(Variable, Term)&gt;? entries);
      Bindings fromBindings(Bindings bindings);
    };
    </pre>

    <p>
      <dfn>bindings()</dfn> returns a new <code>Bindings</code> using the given entries,
      where the entries are represented as an array of key-value pairs.
    </p>    
    <p>
      <dfn>fromBindings()</dfn> returns a copy of the given <code>Bindings</code> using this factory.
    </p>
  </section>

</section>

  <div class="warning" title="Experimental!">
    <p>
      The following interfaces are experimental and will change in future versions of this document:
    </p>
    <p>
      <code>FilterableSource</code>, <code>FilterResult</code>, <code>QueryResultMetadata</code>, <code>QueryResultMetadataCount</code>, <code>QueryResultMetadataOptions</code>, <code>Expression</code>, <code>OperatorExpression</code>, <code>TermExpression</code>, <code>ExpressionFactory</code>
    </p>
  </div>

<section>
  <h2>Filter expression interfaces</h2>
  
  This section introduces interfaces that enable quad sources to be filtered based on a declarative expression.
  
  <section>
    <h2>Goals</h2>
    <ul>
      <li>Query engines MUST be able to push down filters into sources.</li>
      <li>Query engines MUST be able to detect what expressions are supported by sources.</li>
      <li>Query engines MUST be able to obtain the estimated cardinality of any supported expression.</li>
    </ul>
  </section>

  <section data-dfn-for="FilterableSource">
    <h3><dfn>FilterableSource</dfn> interface</h3>

    <pre class="idl">
    interface FilterableSource {
      FilterResult matchExpression (
        optional Term? subject,
        optional Term? predicate,
        optional Term? obj,
        optional Term? graph,
        optional Expression? expression
      );
    };
    </pre>
    
    <p>
      A <code>FilterableSource</code> is an object that produces a <code>FilterableSourceResult</code> that can emit quads.
      The emitted quads can be directly contained in this <code>FilterableSource</code> object, or they can be generated on the fly.
    </p>
    <p>
      <code>FilterableSource</code> is not necessarily an extension of the <a href="https://rdf.js.org/stream-spec/#source-interface">RDF/JS Source interface</a>, but implementers MAY decide to implement both at the same time.
    </p>
    <p>
      <dfn>matchExpression()</dfn> Returns a <code>FilterableSourceResult</code> that contains a quad stream that processes all quads matching the quad pattern and the expression.
    </p>
    <p>
      When a <code>Term</code> parameter is defined, and is a <code>NamedNode</code>, <code>Literal</code> or <code>BlankNode</code>,
      it must match each produced quad, according to the <a href="http://rdf.js.org/data-model-spec/#quad-interface"><code>Quad.equals</code></a> semantics.
      When a <code>Term</code> parameter is a <code>Variable</code>,
      or it is undefined, it acts as a wildcard, and can match with any <code>Term</code>.
    </p>
    <p class="note">
      When matching with <code>graph</code> set to <code>undefined</code> or <code>null</code>
      it MUST match all the graphs (sometimes called <em>the union graph</em>). To match only <em>the default graph</em>
      set <code>graph</code> to a <code>DefaultGraph</code>
    </p>
    <p>
      When an <code>Expression</code> parameter is defined, the complete quad stream is filtered according to this expression.
      When it is undefined, no filter is applied.
    </p>
    <p>
      If parameters of type <code>Variable</code> with an equal variable name are in place,
      then the corresponding quad components in the resulting quad stream MUST be equal.
    </p>
    <p>
      <code>Expression</code>'s MAY contain <code>Variable</code> <code>Term</code>'s.
      If their variable names are equal to <code>Variable</code>'s in the given quad pattern,
      then the <code>Expression</code> MUST be instantiated for each variable's binding in the resulting quad stream when applying the <code>Expression</code> filter.
    </p>
  </section>
  
  <section data-dfn-for="FilterResult">
    <h3><dfn>FilterResult</dfn> interface</h3>

    <pre class="idl">
    interface FilterResult {
      Stream quads();
      Promise&lt;QueryResultMetadata&gt; metadata(optional QueryResultMetadataOptions? options);
      Promise&lt;boolean&gt; isSupported();
    };
    </pre>
    
    <p>
      A <code>FilterResult</code> is an object that represents the result of a filter expression of <code>FilterableSource</code> for a given quad pattern and expression.
      It MAY create results lazily after one of its methods is invoked.
    </p>
    <p>
      <dfn>quads()</dfn> Returns a <a href="https://rdf.js.org/stream-spec/#stream-interface"><code>Stream<Quad></code></a> containing all the quads that matched the given quad pattern and expression.
    </p>
    <p>
      <dfn>metadata()</dfn> Asynchronously returns a <code>QueryResultMetadata</code>, that contains the metadata of the current result.
    </p>
    <p>
      <dfn>isSupported()</dfn> Asynchronously returns a boolean indicating if the requested expression is supported by the <code>FilterableSource</code>.
      If it returns <code>true</code>, <code>quads()</code> and <code>metadata()</code> MAY produce a valid result.
      If it returns <code>false</code>, <code>quads()</code> MUST return a stream emitting an error, and <code>metadata()</code> MUST reject.
    </p>
  </section>
  
  <section data-dfn-for="QueryResultMetadata">
    <h3><dfn>QueryResultMetadata</dfn> interface</h3>

    <pre class="idl">
    interface QueryResultMetadata {
      attribute QueryResultMetadataCount? count;
    };
    </pre>
    
    <p>
      A <code>QueryResultMetadata</code> is an object that represents contains metadata bout a certain query result,
      such as invoking <code>FilterableSource.matchExpression</code>.
    </p>
    <p>
      <dfn>count</dfn> is an optional field that contains metadata about the number of quads in the result stream.
    </p>
  </section>
  
  <section data-dfn-for="QueryResultMetadataCount">
    <h3><dfn>QueryResultMetadataCount</dfn> interface</h3>

    <pre class="idl">
    interface QueryResultMetadataCount {
      attribute string type;
      attribute number value;
    };
    </pre>
    
    <p>
      <code>QueryResultMetadataCount</code> is part of the <code>QueryResultMetadata</code> interface
      to represent metadata about the number of quads in the result stream.
    </p>
    <p>
      <dfn>type</dfn> indicates the type of counting that was done, and MUST either be <code>"estimate"</code> or <code>"exact"</code>.
    </p>
    <p>
      <dfn>value</dfn> indicates an estimate of the number of quads in the stream if <code>type = "estimate"</code>,
      or the exact number  of quads in the stream if <code>type = "exact"</code>.
    </p>
  </section>
  
  <section data-dfn-for="QueryResultMetadata">
    <h3><dfn>QueryResultMetadataOptions</dfn> interface</h3>

    <pre class="idl">
    interface QueryResultMetadataOptions {
      attribute string? count;
    };
    </pre>
    
    <p>
      A <code>QueryResultMetadataOptions</code> is an object that gives suggestions on what type of metadata is desired,
      such as when invoking <code>FilterResult.metadata</code>.
    </p>
    <p>
      <dfn>count</dfn> is an optional field that MAY either contain <code>"estimate"</code> or <code>"exact"</code>.
      If defined, this type MUST correspond to the type in <code>QueryResultMetadataCount</code>.
    </p>
  </section>
  
  <section data-dfn-for="Expression">
    <h3><dfn>Expression</dfn> interface</h3>

    <pre class="idl">
    interface Expression {
      attribute string expressionType;
    };
    </pre>
    
    <p>
      <code>QueryResultMetadataOptions</code> is an abstract interface that represents a generic expression over a stream of quads.
    </p>
    <p>
      <dfn>expressionType</dfn> contains a value that identifies the concrete interface of the expression, since the Expression itself is not directly instantiated.
      Possible values include <code>"operator"</code> and <code>"term"</code>.
    </p>
  </section>
  
  <section data-dfn-for="OperatorExpression">
    <h3><dfn>OperatorExpression</dfn> interface</h3>

    <pre class="idl">
    interface OperatorExpression {
      attribute string expressionType;
      attribute string operator;
      attribute FrozenArray&lt;Expression&gt; args;
    };
    </pre>
    
    <p>
      An <code>OperatorExpression</code> is represents an expression that applies a given operator on given sub-expressions.
    </p>
    <p>
      <dfn>expressionType</dfn> contains the constant <code>"operator"</code>.
    </p>
    <p>
      <dfn>operator</dfn> contains a value that identifies an operator.
      Possible values can be found in <a href="#expression-operators">the list of operators</a>.
    </p>
    <p>
      <dfn>args</dfn> contains an array of <code>Expression</code>'s on to which the given operator applies.
      The length of this array depends on the operator.
    </p>
  </section>
  
  <section data-dfn-for="TermExpression">
    <h3><dfn>TermExpression</dfn> interface</h3>

    <pre class="idl">
    interface TermExpression {
      attribute string expressionType;
      attribute Term term;
    };
    </pre>
    
    <p>
      A <code>TermExpression</code> is an expression that contains a <a href="http://rdf.js.org/data-model-spec/#term-interface"><code>Term</code></a>.
    </p>
    <p>
      <dfn>expressionType</dfn> contains the constant <code>"term"</code>.
    </p>
    <p>
      <dfn>term</dfn> contains a <a href="http://rdf.js.org/data-model-spec/#term-interface"><code>Term</code></a>.
    </p>
  </section>
  
  <section data-dfn-for="ExpressionFactory">
    <h3><dfn>ExpressionFactory</dfn> interface</h3>

    <pre class="idl">
    interface ExpressionFactory {
      OperatorExpression operatorExpression(string operator, sequence&lt;Expression&gt; args);
      TermExpression termExpression(Term term);
    };
    </pre>
    
    <p>
      <code>ExpressionFactory</code> enables expressions to be created in an idiomatic manner.
    </p>
    <p>
      <dfn>operatorExpression</dfn> creates a new <code>OperatorExpression</code> instance for the given operator and array of arguments.
    </p>
    <p>
      <dfn>termExpression</dfn> creates a new <code>TermExpression</code> instance for the given term.
    </p>
  </section>

</section>

<section>
  <h2>Expression operators</h2>

  <p>This section introduces a non-exhaustive list of operators that MAY be used in <code>OperatorExpression</code>.</p>

  <p>Implementers MAY decide to support only a subset of these operators.</p>
  
  <p>We omit any formal semantics behind these operators in this specification, and refer to their <a href="https://www.w3.org/TR/sparql11-query/">SPARQL 1.1. semantics</a>.</p>
  
  <section>
    <h2>Relational operators</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#OperatorMapping">relational operators</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><code>!</code></td>
          <td>
            <ol>
              <li><code>Literal (xsd:boolean)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>The inverse of the given boolean value.</td>
        </tr>
        <tr>
          <td><code>uplus</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The positive value of the given numeric value.</td>
        </tr>
        <tr>
          <td><code>uminus</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The negative value of the given numeric value.</td>
        </tr>
        <tr>
          <td><code>*</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The multiplication of the given values.</td>
        </tr>
        <tr>
          <td><code>/</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The division of the given values.</td>
        </tr>
        <tr>
          <td><code>+</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The addition of the given values.</td>
        </tr>
        <tr>
          <td><code>-</code></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>The subtraction of the given values.</td>
        </tr>
        <tr>
          <td><code>=</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the given values are equal. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>!=</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the given values are not equal. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&lt;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is lesser than the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&gt;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is greater than the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&le;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is lesser than or equal to the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
        <tr>
          <td><code>&ge;</code></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the first value is greater than or equal to the second value. If the terms are <code>Literal</code>s, their lexical value is compared</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>Term functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-rdfTerms">functions on RDF terms</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isIRI"><code>isiri</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>NamedNode</code>. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isBlank"><code>isblank</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>BlankNode</code>. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isLiteral"><code>isliteral</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>Literal</code>. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-isNumeric"><code>isnumeric</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if term is a <code>Literal</code> with a numeric datatype. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-str"><code>str</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the (lexical) string representation of the given term.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-lang"><code>lang</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the language tag of the given <code>Literal</code>, or the empty string if the <code>Literal</code> has no language tag.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-datatype"><code>datatype</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code></li>
            </ol>
          </td>
          <td><code>NamedNode</code></td>
          <td>Returns the datatype of the given <code>Literal</code>.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-iri"><code>iri</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string), <code>NamedNode</code></li>
            </ol>
          </td>
          <td><code>NamedNode</code></td>
          <td>Resolve the given IRI against the base IRI of the current context.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-bnode"><code>bnode</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string), <em>empty</em></li>
            </ol>
          </td>
          <td><code>BlankNode</code></td>
          <td>Create a new blank node with the given label if provided.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strdt"><code>strdt</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string)</li>
              <li><code>NamedNode</code></li>
            </ol>
          </td>
          <td><code>Literal</code></td>
          <td>Returns a new <code>Literal</code> with the given datatype.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strlang"><code>strlang</code></a></td>
          <td>
            <ol>
              <li><code>Literal</code> (xsd:string)</li>
              <li><code>Literal</code> (xsd:string)</li>
            </ol>
          </td>
          <td><code>Literal</code></td>
          <td>Returns a new <code>Literal</code> with the given language tag.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-uuid"><code>uuid</code></a></td>
          <td>/</td>
          <td><code>NamedNode</code></td>
          <td>Returns a new <code>NamedNode</code> following the <a href="https://www.ietf.org/rfc/rfc4122.txt">UUID URN scheme</a>.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-struuid"><code>struuid</code></a></td>
          <td>/</td>
          <td><code>Literal</code> (xsd:string)</td>
          <td>Returns a new <code>Literal</code> following the <a href="https://www.ietf.org/rfc/rfc4122.txt">UUID URN scheme</a>.</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>String functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-strings">string functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strlen"><code>strlen</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the number of characters of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-substr"><code>substr</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:integer)</code></li>
              <li><code>Literal (xsd:integer)</code> (optional)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the substring of the given string starting from the given position (second parameter) with the given length (third parameter). If no third parameter is provided, then the maximum length is taken.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-ucase"><code>ucase</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Transform each character in the given string to upper case.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-lcase"><code>lcase</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Transform each character in the given string to lower case.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strstarts"><code>strstarts</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if the given string starts with the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strends"><code>strends</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if the given string ends with the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strcontains"><code>strcontains</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if the given string contains the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strbefore"><code>strbefore</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>From the given first string, find the full string that occurs before the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-strafter"><code>strafter</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>From the given first string, find the full string that occurs after the given second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-encode"><code>encode_for_uri</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Apply URI encoding on the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-concat"><code>concat</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li> (variable number of arguments)
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Concatenation of all the given strings.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-langMatches"><code>langmatches</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>If the language tag of the first literal matches the second string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-regex"><code>regex</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code> (optional)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Check if on the given first string, the given second regular expression matches. The third parameter indicates optional regex flags.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-replace"><code>replace</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code></li>
              <li><code>Literal (xsd:string)</code> (optional)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>In the given first string, match the given second regular expression, and replace it with the given third string. The fourth parameter indicates optional regex flags.</td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>Numerical functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-numerics">numerical functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-abs"><code>abs</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the absolute value of the given numerical term.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-round"><code>round</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the number with no fractional part that is closest to the argument, with preference for rounding up.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-ceil"><code>ceil</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the smallest (closest to negative infinity) number with no fractional part that is not less than the value of arg.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-floor"><code>floor</code></a></td>
          <td>
            <ol>
              <li><code>Literal (numeric)</code></li>
            </ol>
          </td>
          <td><code>Literal (numeric)</code></td>
          <td>Returns the largest (closest to positive infinity) number with no fractional part that is not greater than the value of arg.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-rand"><code>rand</code></a></td>
          <td>
            /
          </td>
          <td><code>Literal (xsd:double)</code></td>
          <td>Returns a pseudo-random, number between 0 (inclusive) and 1.0e0 (exclusive). Different numbers can be produced every time this function is invoked. Numbers should be produced with approximately equal probability.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Date and time functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-date-time">date and time functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-now"><code>now</code></a></td>
          <td>
            /
          </td>
          <td><code>Literal (xsd:dateTime)</code></td>
          <td>Returns an XSD dateTime value for the current query execution. All calls to this function in any one query execution must return the same value.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-year"><code>year</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the year of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-month"><code>month</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the month of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-day"><code>day</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the day of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-hours"><code>hours</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the hours of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-minutes"><code>minutes</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the minutes of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-seconds"><code>seconds</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Returns the seconds of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-timezone"><code>timezone</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:dayTimeDuration)</code></td>
          <td>Returns the timezone part of the given date.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-tz"><code>tz</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:dateTime)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the timezone part of the given date.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>Hash functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-hash">hash functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-md5"><code>md5</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the MD5 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha1"><code>sha1</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA1 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha256"><code>sha256</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA256 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha384"><code>sha384</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA384 checksum of the given string.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sha512"><code>sha512</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:string)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Returns the SHA512 checksum of the given string.</td>
        </tr>
      </tbody>
    </table>
  </section>

  <section>
    <h2>XPath constructor functions</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#FunctionMapping">XPath constructor functions</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#string</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:string)</code></td>
          <td>Cast the given term to <code>xsd:string</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#float</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:float)</code></td>
          <td>Cast the given term to <code>xsd:float</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#double</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:double)</code></td>
          <td>Cast the given term to <code>xsd:double</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#decimal</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:decimal)</code></td>
          <td>Cast the given term to <code>xsd:decimal</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#integer</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:integer)</code></td>
          <td>Cast the given term to <code>xsd:integer</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#dateTime</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:dateTime)</code></td>
          <td>Cast the given term to <code>xsd:dateTime</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#date</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:date)</code></td>
          <td>Cast the given term to <code>xsd:date</code></td>
        </tr>
        <tr>
          <td><code>http://www.w3.org/2001/XMLSchema#boolean</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Cast the given term to <code>xsd:boolean</code></td>
        </tr>
      </tbody>
    </table>
  </section>
  
  <section>
    <h2>Functional forms</h2>
    
    This section introduces <a href="https://www.w3.org/TR/sparql11-query/#func-forms">functional operators</a>.
  
    <table>
      <thead>
        <tr><th>Name</th><th>Input</th><th>Output</th><th>Description</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-bound"><code>bound</code></a></td>
          <td>
            <ol>
              <li><code>Variable</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if the given variable is bound to a value. Returns false otherwise.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-if"><code>if</code></a></td>
          <td>
            <ol>
              <li><code>Expression</code></li>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Term</code></td>
          <td>Evaluates the expression as <a href="https://www.w3.org/TR/sparql11-query/#ebv">effective boolean value</a>. Returns the second argument if true, otherwise the third argument.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-coalesce"><code>coalesce</code></a></td>
          <td>
            <ol>
              <li><code>Expression</code> (variable number of arguments)</li>
            </ol>
          </td>
          <td><code>Term</code></td>
          <td>Returns the first expression result that evaluates without an error.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-or"><code>||</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:boolean)</code></li>
              <li><code>Literal (xsd:boolean)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns a logical OR of left and right. Note that logical-or operates on the <a href="https://www.w3.org/TR/sparql11-query/#ebv">effective boolean value</a> of its arguments.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-logical-and"><code>&amp;&amp;</code></a></td>
          <td>
            <ol>
              <li><code>Literal (xsd:boolean)</code></li>
              <li><code>Literal (xsd:boolean)</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns a logical AND of left and right. Note that logical-or operates on the <a href="https://www.w3.org/TR/sparql11-query/#ebv">effective boolean value</a> of its arguments.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal"><code>=</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if both terms are the same follow these <a href="https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal">rules</a>. A type error is produced if both arguments are literals but not the same.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-sameTerm"><code>sameterm</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Term</code></li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Returns true if both terms are the same follow these <a href="https://www.w3.org/TR/sparql11-query/#func-RDFterm-equal">rules</a>. False is returned instead of type errors.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-in"><code>in</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Expression</code> (variable number of arguments)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Tests whether the RDF term on the left-hand side is found in the values of list of expressions on the right-hand side.</td>
        </tr>
        <tr>
          <td><a href="https://www.w3.org/TR/sparql11-query/#func-not-in"><code>notin</code></a></td>
          <td>
            <ol>
              <li><code>Term</code></li>
              <li><code>Expression</code> (variable number of arguments)</li>
            </ol>
          </td>
          <td><code>Literal (xsd:boolean)</code></td>
          <td>Tests whether the RDF term on the left-hand side is not found in the values of list of expressions on the right-hand side.</td>
        </tr>
      </tbody>
    </table>
  </section>
</section>

</body>
</html>
